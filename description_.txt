Для определения настроек для загрузки текстового файла был написан класс autoSettings.
Класс имеет следующие атрибуты:
1. row_separators - список возможных разделителей строк
2. column_separators - список возможных разделителей колонок (столбцов)
3. detector - детектор, используемый для определения кодировки файла
Следующие атрибуты являются настройками для загрузки файла:
4. row_sep - разделитель строк
5. column_sep - разделитель столбцов
6. decimal_sep - десятичный разделитель 
7. code_standart - кодировка файла
8. rubbish_lines_toHead - число строк с мусором до заглоовка
9. head_lines - число строк заголовка
10. rubbish_lines_afterHead - число строк с мусором после заголовка
11. meaning_data_lines - число значащих строк данных

Для получения настроек загрузки данных используется метод get_auto_settings (filenamne), которому передается расположения файла.
(Все остальные методы класса являются приватными.)
Данный метод работает следующим образом:
1. открывается файл для чтения в двоичном режиме
2. считываются первые и последние 10000 знаков (читать файл полностью нет необходимости, так же это уменьшет время работы программы)
3. определяется разделитель строк с помощью метода __searchRowSeparator(), которому передается первые 10000 знаков в файле
	3.1 с помощью метода __separator() находится первый разделитель в файле
	3.2 с помощью метода __separatorChecking() проверяется, остаются ли в файле другие разделители, 
	если да, то в качестве разделителя строк выбирается символ, который встречается в файле чаще всего
4. полученным на предыдущем шаге символом делятся на строки начало и конец файла, полученные на шаге 2
5. определяется кодировка файла с помощью метода __codeStandart(), которому передаются строки с предыдущего шага
	(метод реализован на основе использования детектора из библиотеки chardet)
6. декодируем данные для дальнешего их использования
7. удаляем лишние пробелы с начала и конца строк из списков, полученных на шаге 4 , 
	а так же удаляем последнюю строку из списка начальных строк файла и первую строку из  списка последних строк файла,
	так как они могут быть неполнымы из-за того, что читаются определенное число знаков, а не строк
	
8. определяется разделитель колонок с помощью метода __searchColumnSeparator, 
	которому передается перевернутый список строк с конца файла:
	8.1 ищется строка с значащими данными, то есть пропускасются строки с мусором
	8.2 число колонок, полученное на предыдущей итерации, сравнивается с числом колонок в текущей строке 
	8.2 определяется число колонок в строке для каждого возможного разделителя
	8.3 если полученное число колонок равно 1 или рассматриваемая строка не явлется числовой для какого-то разделителя
		(проверка осущетсвляется с помощью метода __isStringOfNumbers()), то данный разделитель удаляется из списка возможных
		иначе данный символ и соответствующее число колонок запоминаются и осуществляется переход к следующей строке
	8.4 поиск продолжается до тех пор, пока число колонок не совпадет для двух строк подряд
9. определяется число строк с мусором после строк с данными и количество колонок в строке с значащими данными
	с помощью метода __rubbish_lines_afterData, которому передается список строк с конца файла(перевернутый):
	считаем до тех пор, пока не будет найдена строка с значащими данными
	то есть до тех пор, пока не будет найдена числовая строка, где количество колонок больше 1 и пока это число не совпадет для 2х подряд идущих строк
10. определяется число строк с мусором после заголовка и список строк с начала файла (без строк с значащими данными)
	с помощью метода __rubbish_afterHead(), 
	которому передается список строк с начала файла (перевернутый):
	10.1 для начала пропускаются строки с значащими данными
	10.2 считаем до тех пор, пока не будет найдена строка заголовка
		(строка считается заголовком, если число колонок в ней совпадет с числом колонок строки с значащими данными
		и в ней есть числа или буквы (в каждой колонке))
11. определяется число строк заголовка с помощью метода __headRows(), 
	которому передается список, полученный на предыдущем шаге, без мусора (после заголовка) и число столбцов в строках значащих данных:
	строка считается заголовком, если число столбцов в ней равно числу столбцов в строке значащих данных и в ней есть буквы или цифры (в каждой колонке) 
12. определяется число строк с мусором до заголовка как длина списка, полученного на шаге 10 без строк заголовка и мусора после него
13. определяется число строк значащих данных как число всех строк в файле без строк с мусором и строк заголовка
14. определяется десятичный разделитель с помощью метода __decimalSeparator(), 
	которому передается строка с значащими данными, разделенная на столбцы
	14.1 производится попытка преобразовать строку в число с помощью функции float()
	14.2 если получено исключение ValueError, то в строке ',' заменяется на '.' и снова преобразутеся в число, 
	иначе переход к следующему столбцу
	14.3 если снова получено исключение, то обрабатывается следующий столбец, 
	иначе десятичням разделителем является символ ','
	14.4 если исключение не было получено вообще, то десятичным разделителем является '.'
		
15. возвращается словарь с найденными параметрами загрузки


